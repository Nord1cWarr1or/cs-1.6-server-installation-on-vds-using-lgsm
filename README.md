# Установка и первичная настройка игрового сервера Counter-strike на VDS

## Часть 0. Предисловие

### Copyright ©
Данная статья написана лично мной с использованием моего личного опыта и открытых источников, ссылки на которые я предоставляю в конце каждого раздела.
Распространение данной статьи запрещено без указания ссылки на первоисточник и никнейма (контакта) автора.
Первоисточником считать: [Nord1cWarr1or/cs-1.6-server-installation-on-vds-using-lgsm (github.com)](https://github.com/Nord1cWarr1or/cs-1.6-server-installation-on-vds-using-lgsm)
Автор: Nordic Warrior. (Telegram: @NordicWarrior)
Дата написания: октябрь-ноябрь 2021 г.

### Пара слов от автора
На написание данной статьи меня сподвигло отсутствие таковых подробных статей и инструкций по установке сервера на конец 2021 года.
Всё, что мне удавалось найти либо устарело, либо не было достаточно подробным или рассматривало только какой-то один процесс в установке сервера. Я решил сделать единый гайд, с актуальными сведениями, полностью подробный и понятный даже для незнакомых с этой сферой людей.

***Примечание***: Я буду рассматривать только установку на ОС Linux, и даже более конкретно, Debian. Я привык работать с ней, а команды на других основных дистрибутивах различаются незначительно, поэтому нет смысла растягивать статью. Так же я буду использовать только скрипт LGSM, поскольку считаю его самым эффективным бесплатным инструментом для управления сервером Counter-strike 1.6.

### Софт, который нам понадобится: 
1. FTP клиент. Я пользуюсь [FileZilla](https://filezilla-project.org/)
2. SSH клиент. Я пользуюсь [PuTTY](https://www.chiark.greenend.org.uk/~sgtatham/putty/)
3. (Опционально) Хороший текстовый редактор. Я использую [Notepad++ (notepad-plus-plus.org)](https://notepad-plus-plus.org/)

Вы можете использовать те решения, что нравятся вам.

## Часть 1. Первичная настройка системы
### Выбор хостинга...
...я возлагаю на вас самих. Существует великое множество хостингов, разнящихся ценами, оборудованием, локацией и т.п. Рассматривать этот аспект здесь нет никакого смысла. Кто-то вообще содержит свой собственный домашний сервер.

Скажу лишь примерные характеристики виртуальной машины, на которые вам желательно ориентироваться.
- Процессор: рекомендую 2.5-3.5 ГГц, 1 ядро под каждый сервер. То есть если вы собираетесь держать два сервера, заказываете 2 ядра и т.д.
- Оперативная память: 2гб, если вы собираетесь устанавливать http сервер и базу данных MySQL, в противном случае хватит и 1гб.
- Жёсткий диск (или SSD): 10гб вполне хватит на 1-2 сервера.

### Данные и вход
Итак, мы определились с выбором хостинга и арендовали сервер. На некоторых хостингах требуется вручную начать установку системы.

Для начала, заходим в панель управления сервером и ищем там данные для подключения к нему. Нас интересует подключение по SSH и IP-адрес сервера.

После того как мы получили данные (рекомендую их записать куда-нибудь в надёжное место, например создать текстовый документ), открываем PuTTY и добавляем туда подключение к нашему серверу. Тип соединения ставим SSH, вводим IP и пароль нашего сервера. Подключиться!

Мы попадаем на страницу входа в аккаунт. Открываем данные, которые мы записали минуту назад и заходим.

### Подготовка виртуальной машины
После того как мы вошли в учётную запись root, и перед тем, как мы приступим к первичной настройке виртуальной машины, необходимо обновить весь имеющийся у нас софт. Вводим в консоль:
```
apt update && apt full-upgrade
```
и дожидаемся окончания выполнения команд.

***Примечание***: Если на вашем хостинге недоступна последняя версия дистрибутива ОС, и стоит, например Debian 10, то `apt update` может выдать вам следующее:
```
E: Repository 'http://security.debian.org/debian-security buster/updates InRelease' changed its 'Suite' value from 'stable' to 'oldstable'
N: This must be accepted explicitly before updates for this repository can be applied. See apt-secure(8) manpage for details.
```
Здесь система сообщает нам о том, что репозитории поменяли свою метку со stable на oldstable и предложит согласиться с изменениями: `Do you want to accept these changes and continue updating from this repository? [y/N]`. Соглашаемся, жмём enter, пока не начнётся установка.

### Добавление пользователя
Теперь приступим к первичной настройке виртуальной машины.
Для начала, нам нужно создать нового пользователя и наделить его правами администратора, так как не рекомендуется работать из-под root пользователя в целях безопасности.
Вводим `adduser имя_пользователя`. Например:
```
adduser public_server
```
Система попросит нас ввести поочерёдно пароль для пользователя, затем подтверждение пароля. Дальше нас просят ввести информацию о пользователе, но это делать совершенно не обязательно. Нажимаем последовательно enter, дожидаясь вопроса `Is the information correct? [Y/n]`, и вводим Y, enter.

Установим пакет **sudo**, отвечающий за выполнение администраторских команд не от **root** юзера.
```
apt install sudo
```
Далее предоставим новоиспечённому пользователю права администратора. 
Вписываем `usermod -aG sudo имя_пользовтеля`. У нас это:
```
usermod -aG sudo public_server
```

### Настройка брандмауэра (UFW)
Следующим шагом выполним установку и базовую настройку брандмауэра.
Те, кто хочет использовать другие решения по защите сети, например iptables или защиту от хостинга, могут пропустить этот шаг.

Для начала установим пакет `UFW`. Вписываем в терминал:
```
apt install ufw
```
Это и есть наш брандмауэр. Переходим к его настройке.
Для начала запретим все входящие соединения и разрешим исходящие. Выполняем команду:
```
ufw default deny incoming && ufw default allow outgoing
```
Теперь нам надо разрешить те входящие соединения, которые потребуются нам для корректной работы сервера.
Прежде всего разрешим SSH, так как это, собственно, доступ к терминалу сервера. Вводим:
```
ufw allow ssh
````
Затем разрешим http соединения, которые понадобятся для быстрой загрузки (и работы веб-дополнений).
```
ufw allow http
```
Те, кто собирается организовывать, например, полноценный форум или сайт, скорее всего будут использовать протокол с шифрованием, так что им следует разрешить ещё и https:
```
ufw allow https
```
И конечно же, нам потребуется разрешить входящие соединения на порт, который будет использовать игровой сервер. У меня это стандарт - 27015. Выполняем:
```
ufw allow 27015
```
Теперь активируем брандмауэр командой:
```
ufw enable
```
Система предупредит вас, что активация может прервать соединение, но поскольку мы настроили всё правильно, соглашаемся, нажав Y и enter.

На этом настройка брандмауэра окончена. Если вы сомневаетесь в её правильности, проверить можно, выполнив команду `ufw status verbose`. Если защита включена, вы получите список разрешающих/запрещающих правил.

На всякий случай приведу здесь базовые команды для отключения/сброса брандмауэра.
- `ufw disable` - отключение.
- `ufw reset` - сброс.
- `ufw status numbered` - вывод списка активных правил и их номеров.
- `ufw delete номер_правила` - удаление определённого правила по его номеру.

#### Литература
- [Настройка брандмауэра с UFW в Debian 9 | DigitalOcean](https://www.digitalocean.com/community/tutorials/how-to-set-up-a-firewall-with-ufw-on-debian-9-ru)

## Часть 2. Установка и настройка скрипта LGSM
Теперь переходим к мозгу нашего будущего сервера: скрипту, управляющему сервером.

### Установка LGSM

#### Установка зависимостей
Переходим в пользователя, которого мы создали на предыдущем этапе: `su - public_server`.
Для начала установим зависимости — пакеты, которые требуются для нормальной работы скрипта. Вводим в терминал: 
```
sudo dpkg --add-architecture i386; sudo apt update; sudo apt install curl wget file tar bzip2 gzip unzip bsdmainutils python util-linux ca-certificates binutils bc jq tmux netcat lib32gcc1 lib32stdc++6
```
Вводим пароль пользователя для подтверждения и ждём завершения.

***Примечание***: на Debian 11 я получил предупреждение о том, что пакет `lib32gcc1` в репозитории был заменён пакетом `lib32gcc-s1`. Если вы получили такое же сообщение, просто замените название пакета в строке выше.

Далее выполняем команду, загружающую скрипт в текущую папку:
```
wget -O linuxgsm.sh https://linuxgsm.sh && chmod +x linuxgsm.sh && bash linuxgsm.sh csserver
```

##### Литература
- [Counter-Strike | LinuxGSM_](https://linuxgsm.com/lgsm/csserver/)

#### (Опционально) Выбираем имя скрипта
На текущем этапе, если вы хотите задать своё имя скрипта, вместо стандартного `csserver`, это можно легко сделать. В противном случае, этот шаг можно пропустить.
Ниже по тексту я не буду изменять имя скрипта со стандартного, чтобы не было путаницы.

Чтобы переименовать скрипт, воспользуйтесь командой `mv`:
```
mv csserver новое_имя
```
Например: `mv csserver public`.

#### Процесс установки
Запускаем автоматическую установку командой:
```
./csserver auto-install
```
Скрипт сам проверит, установлены ли все зависимые компоненты, и если нет, установит их.
Если установка скрипта и сервера прошла успешно, вы получите соответствующую надпись об этом.

Теперь можно попробовать запустить сервер для проверки.
Пишем в терминале:
```
./csserver start
```
Если всё успешно, можно попробовать подсоединиться к серверу.
Для подключения используйте IP VDS-сервера и стандартный порт 27015.

***Примечание***: на текущем этапе зайти на сервер можно только с лицензионной версии игры.
***Важно***: выходить из консоли следует **только** через сочетание клавиш `CTRL + B`, затем `D`. Если вы попытаетесь выйти из консоли нажав по обыкновению `CTRL + C`, это завершит процесс сервера.

#### Активация полных краш-логов
На этом этапе можно сразу же активировать создание полных краш-логов. Иначе если у вас будет падать сервер, вам никто не сможет помочь. Делается это быстро и просто.

Устанавливаем через терминал пакет gdb, пишем:
```
apt install gdb
```
Подключаемся к серверу через FileZilla, используя SFTP протокол. Для этого вводим в поле "Хост" адрес вашего сервера, логин и пароль в соответствующие поля (не забываем, что войти нам сейчас надо не за root, а за пользователя, у которого установлен наш скрипт), а в поле "Порт" пишем "22", что соответствует SFTP. Подключаемся.
Мы попадаем в домашнюю директорию пользователя, в примере я использовал `public_server`.

Далее переходим в папку `serverfiles` через FileZilla и находим здесь файл `hlds_run`.
Открываем его для редактирования. Поиском находим такую строку:
```
ulimit -c 2000
```
и заменяем 2000 на "unlimited", чтобы получилось так:
```
ulimit -c unlimited
```
На этом всё! Сохраняем и закрываем файл.

##### Литература
- [Как получить Dump падения HLDS | Dev-CS.ru](https://dev-cs.ru/threads/1532/#post-18163)

### Настройка LGSM
Теперь можно перейти к настройкам скрипта.
Первое, что нам нужно сделать, это сконфигурировать основные настройки.

#### Настройки сервера и скрипта
Заходим через FTP-клиент в папку `lgsm -> config-lgsm -> csserver`. Здесь хранятся конфиги LGSM.
Нас интересует конфиг `csserver.cfg`, который отвечает за наш игровой сервер.
Открываем его и производим первичную настройку.

Все доступные параметры можно посмотреть в стандартном конфиге `_default.cfg`, который находится в этой же директории. Описания к ним можно прочитать по ссылкам, приведённым в конфиге.

Я приведу пример своих настроек.
```
##################################
####### Instance Settings ########
##################################
# PLACE INSTANCE SETTINGS HERE
## These settings will apply to a specific instance.

#### Game Server Settings ####

## Predefined Parameters | https://docs.linuxgsm.com/configuration/start-parameters
ip="0.0.0.0"
port="27015"
clientport="27005"
defaultmap="de_dust2"
maxplayers="16"

## Server Parameters | https://docs.linuxgsm.com/configuration/start-parameters#additional-parameters
startparameters="-game cstrike -strictportbind +ip ${ip} -port ${port} +clientport ${clientport} +map ${defaultmap} +servercfgfile ${servercfg} -maxplayers ${maxplayers} -pingboost 3 -debug"

#### LinuxGSM Settings ####

## Backup | https://docs.linuxgsm.com/commands/backup
maxbackups="4"
maxbackupdays="30"
stoponbackup="on"

## Logging | https://docs.linuxgsm.com/features/logging
consolelogging="on"
logdays="7"

#### Directories ####
# Edit with care

## Game Server Directories
systemdir="${serverfiles}/cstrike"
executabledir="${serverfiles}"
executable="./hlds_run"
servercfgdir="${systemdir}"
servercfg="${servercfgdefault}"
servercfgdefault="server.cfg"
servercfgfullpath="${servercfgdir}/${servercfg}"
```
Вообще, на мой взгляд здесь интуитивно всё понятно, но всё-таки я считаю должным пройтись по этому конфигу.
- `ip` - отвечает за IP сервера. Если на предыдущем шаге у вас получилось зайти на сервер, оставьте его в стандартном виде. `0.0.0.0` - обозначает автоматическое определение IP-адреса. В противном случае можно попробовать вставить сюда непосредственно IP сервера.
- `port` - желаемый порт сервера. Не забываем давать доступ к нему через UFW.
- `clientport` - клиентский порт. Не трогаем.
- `defaultmap` - карта, с которой будет стартовать сервер.
- `maxplayers` - кол-во слотов сервера.
- `startparameters` - параметры запуска сервера.
- `maxbackups` - максимальное кол-во хранимых бэкапов сервера.
- `maxbackupdays` - сколько дней будет храниться каждый бэкап.
- `stoponbackup` - останавливать ли сервер во время бэкапа. Лучше оставить включённым.
- `consolelogging` - лог всего происходящего в консоли сервера. На мой взгляд, очень удобная фича, которой не хватает на хостингах.
- `logdays` - сколько дней будут храниться логи.
- `systemdir` - директория, где находится корневая папка игрового сервера.
- `executabledir` - директория, где находится корневая папка самого скрипта.
- `executable` - название исполняемого файла скрипта. Не рекомендую трогать само название, но сюда можно приписать параметры запуска процесса сервера, например привязку к определённому ядру процессора.
- `servercfgdir` - директория, где находится конфиг игрового сервера (server.cfg).
- `servercfg` - название конфига игрового сервера.Здесь я изменил значение на `"${servercfgdefault}"`, чтобы использовать более привычное для CS 1.6 название `server.cfg`. По стандарту здесь указано `"${selfname}.cfg"` - название конфига по имени скрипта. В результате было: `csserver.cfg`.
- `servercfgdefault` - стандартное название конфига. Не меняем.
- `servercfgfullpath` - полный путь до конфига сервера.

После того как настроили конфиг, перезапускаем сервер командой `./csserver restart`, чтобы настройки применились.

#### Команды скрипта
Лучше всего сразу изучить команды, которыми располагает наш скрипт. Для этого введём `./csserver` - тогда появится список всех команд с их описанием.

Я приведу с переводом здесь основные, которые могут нам понадобиться. 

Команда | Сокращение | Описание
-|-|-
start | st | Запускает сервер
stop | sp | Останавливает сервер
restart | r | Перезапускает сервер
monitor | m | Проверяет доступность сервера и перезапускает его в случае падения
test-alert | ta | Отправляет тестовое предупреждение (об этом позже)
details | dt | Показывает основную информацию о сервере
postdetails | pd | То же, что и предыдущее, только загружает информацию на сервис Termbin (аналог Pastebin) и выдаёт ссылку
update-lgsm | ul | Проверяет и производит обновление скрипта LGSM
backup | b | Делает бэкап сервера
console | c | Открывает консоль игрового сервера
send | sd | Даёт возможность отправить команду в консоль сервера, не заходя в неё

#### Литература
- [Home - LinuxGSM_](https://docs.linuxgsm.com/)

### Настройка расписаний
Настало время выполнить немаловажную часть нашей работы — настроить расписания для автоматизации важных для работы сервера действий.

Сейчас мы установим:
- Перезагрузку виртуальной машины раз в месяц.
- Автоматический запуск сервера при включении виртуальной машины.
- Перезагрузку игрового сервера раз в сутки.
- Создание бэкапа сервера каждые две недели.
- "Мониторинг" сервера на предмет падений.

Приступим.
Делать будем всё при помощи стандартной утилиты Linux - "crontab".
Для начала, зайдём в терминале за пользователя root: `su - root`. Вводим пароль. Далее вызываем окно редактирования crontab. Пишем:
```
crontab -e
```
Если вы выполняете эту команду впервые на текущей виртуальной машине, система попросит выбрать вас, какой текстовый редактор вы предпочитаете использовать (и если в вашем дистрибутиве установлено несколько редакторов "из коробки"). В моём случае мне предложили **Vim** или **nano**. Всем новичкам я настоятельно рекомендую выбрать именно nano, поскольку Vim имеет весьма специфическое управление.

Итак, вы выбрали редактор и перед вами открылся файл, содержащий cron jobs (именно так они называются). По умолчанию он пуст (не считая "комментариев").
Обратите внимание, что каждый cron job пишется с новой строки.

Стрелками на клавиатуре опускаем ввод в самый низ.
Устанавливаем перезагрузку виртуальной машины. Разумнее будет сделать её под утро, когда на сервере низкий онлайн. Я выбрал время 4 утра. 
```
0 4 1 * * reboot
```
Нажимаем CTRL + X, система предложит сохранить наш файл с заданиями. Жмём Y.

Можно проверить, что мы всё сделали правильно, пишем следующую команду:
```
crontab -l
```
которая выведет на экран содержимое файла. Если вы видите в конце строчку, которую только что вписали, значит всё в порядке.

Далее, для работы с заданиями по игровому серверу, лучше всего использовать юзера, под которым работает наш скрипт. Можно перейти в учётную запись этого юзера и повторить действия выше, а можно просто отредактировать файл заданий того юзера, не выходя с root.

Пишем:
```
crontab -u имя_пользователя -e
```
Откроется такой же самый файл, только в дальнейшем он будет исполняться от нашего пользователя, запускающего LGSM.

Настроим автоматический запуск сервера после включения виртуальной машины:
```
@reboot ./csserver st > /dev/null 2>&1
```
Установим перезагрузку игрового сервера раз в сутки. Опять же, ранним утром:
```
0 4 * * * ./csserver r > /dev/null 2>&1
```
Далее зададим резервное копирование раз в две недели (в 04:05, после перезагрузки):
```
5 4 */14 * * ./csserver b > /dev/null 2>&1
```
И наконец, добавим мониторинг сервера на доступность.
Команда `monitor`, которая будет проверять сервер на предмет падений, например, каждые 5 минут:
```
*/5 * * * * ./csserver m > /dev/null 2>&1
```

Для справки: `> /dev/null 2>&1` - используется для блокировки текстового вывода на экран от выполнения команды.

#### Литература
- [Home - LinuxGSM_](https://docs.linuxgsm.com/)
- [Crontab.guru - The cron schedule expression editor](https://crontab.guru/) - неплохой сервис для настройки времени cron'ов.

## Часть 3. Установка основных дополнений. Настройка игрового сервера
Теперь пришло время заняться самим игровым сервером. И начнём мы с движка.

### Установка ReHLDS
Переходим по ссылке: [Releases · dreamstalker/rehlds (github.com)](https://github.com/dreamstalker/rehlds/releases). Скачиваем и устанавливаем последний релиз.

Установка предельна проста: выключаем наш сервер командой `./csserver sp` и просто загружаем файлы через FileZilla в *корневую папку сервера* (то есть /serverfiles), заменяя текущие. Включаем сервер, заходим в консоль и проверяем версию командой `version`.

На момент написания статьи я получаю такой вывод:
```
Protocol version 48
Exe version 1.1.2.7/Stdio (cstrike)
ReHLDS version: 3.11.0.767-dev
Build date: 03:13:55 Oct 25 2021 (2753)
Build from: https://github.com/dreamstalker/rehlds/commit/471158b
```

#### Создание и настройка конфига
Поскольку ReHLDS не имеет собственного конфига, мы создадим его своими руками. Переходим в папку cstrike и создаем файл `rehlds.cfg`. Открываем его, и вписываем туда те квары[^1], которые привносит в движок именно ReHLDS. И добавим строчку, которая будет выводиться в консоль при чтении конфига.
```
echo Executing ReHLDS Configuration File

// Конфигурационный файл для ReHLDS

// Автоматически подгружать звуки, используемые в v_* моделях
sv_auto_precache_sounds_in_models "0"

// Загружать пользовательские спреи после входа в игру, а не при подключении. Это увеличивает скорость загрузки
sv_delayed_spray_upload "1"

// Выводить в консоль попытки использования неизвестных команд
sv_echo_unknown_cmd "1" 

// Позволяет отключить логирование пароля RCON
sv_rcon_condebug "0"

// Исправлять застревание на передвижной платформе/энтити. (Глобальная проблема на DeathrunMod и на картах с транспортом эвакуации)
sv_force_ent_intersection "0"

// Принудительно выставить клиентский квар cl_dlmax 1024. Позволяет избежать чрезмерной фрагментации пакетов
sv_rehlds_force_dlmax "1"

// Устанавливает размер энтити по центру
sv_rehlds_hull_centering "0"

// Отправлять mapcycle.txt в сообщении serverinfo (Не используется на клиенте)
sv_rehlds_send_mapcycle "0"
       
// Исправляет ошибку с анимациями модели игрока, когда игрок имеет присоединенные объекты (aiments). Может вызвать отставание анимации, когда cl_updaterate низка
sv_rehlds_attachedentities_playeranimationspeed_fix "0"

// Ограничить количество подключений с одного IP-адреса
sv_rehlds_maxclients_from_single_ip "5"

// Позволяет использовать свой список энтити для карт. Файл с энтити находится по адресу "maps/[map name].ent")
// 0 - использовать исходные энтити.
// 1 - использовать файлы .ent из каталога карт.
// 2 - использовать файлы .ent из каталога карт и создать новый файл .ent, если он отсутствует.
sv_use_entity_file "0"

// Функция локального игрового времени, которая уменьшает лаги, если у вас долго запущена одна и та же карта
sv_rehlds_local_gametime "0"

// Максимальный средний уровень «move» команд для бана
sv_rehlds_movecmdrate_max_avg "400"
 
// Время в минутах, на которое игрок будет забанен (0 - навсегда, отрицательное число - кикнуть)
sv_rehlds_movecmdrate_avg_punish "-1"

// Максимальное отклонение уровня «move» команд для бана
sv_rehlds_movecmdrate_max_burst "2500"

// Время в минутах, на которое игрок будет забанен (0 - навсегда, отрицательное число - кикнуть)
sv_rehlds_movecmdrate_burst_punish "-1"

// Максимальный средний уровень «string» команд для бана
sv_rehlds_stringcmdrate_max_avg "80"

// Время в минутах, на которое игрок будет забанен (0 - навсегда, отрицательное число - кикнуть)
sv_rehlds_stringcmdrate_avg_punish "-1"

// Максимальное отклонение уровня «string» команд для бана
sv_rehlds_stringcmdrate_max_burst "400"

// Время в минутах, на которое игрок будет забанен (0 - навсегда, отрицательное число - кикнуть)
sv_rehlds_stringcmdrate_burst_punish "-1"

// setinfo поля которые будут переданы клиентам от сервера.
// Если значение не установлено, то все поля будут переданы, за исключением приставки с подчеркиванием (к примеру _ah). Каждый ключ должен начинаться на слеш.
// Например "/name/model/*sid/*hltv/bottomcolor/topcolor"
// Больше информации: https://github.com/dreamstalker/rehlds/wiki/Userinfo-keys
sv_rehlds_userinfo_transmitted_fields ""

// Если включено, сервер будет устанавливать дополнительное случайное число независимо от клиента. Используется для того чтобы сломать norecoil в читах.
sv_usercmd_custom_random_seed "0"
```
Теперь открываем `server.cfg` и добавляем в самый конец такую строчку: `exec rehlds.cfg`.
Готово!

### Установка ReGameDLL
Далее поставим ReGameDLL.
Повторяем предыдущие действия, скачиваем последний релиз с GitHub: [Releases · s1lentq/ReGameDLL_CS (github.com)](https://github.com/s1lentq/ReGameDLL_CS/releases).
Выключаем сервер, заменяем файлы в корне сервера, включаем обратно. Проверяем свои действия командой в консоли `game version`.
На текущий момент увидим следующее:
```
ReGameDLL version: 5.21.0.540-dev
Build date: 17:33:16 Oct 25 2021
Build from: https://github.com/s1lentq/ReGameDLL_CS/commit/b9cccc6
```
Сразу, не отходя от кассы, можно настроить под свой сервер конфиг `game.cfg`, отвечающий за геймплей на сервере.
Не стану разбирать его здесь, потому что, во-первых, это потребует целой отельной статьи, во-вторых, это слишком индивидуально от сервера к серверу и в-третьих, в нём уже имеются подписи к каждому квару.

### Установка Metamod
Мы будем использовать Metamod-r, поскольку эта версия содержит множество оптимизаций и исправлений, а так же полностью совместима с ReHLDS.

Переходим по ссылке: [Releases · theAsmodai/metamod-r (github.com)](https://github.com/theAsmodai/metamod-r/releases) и скачиваем последний доступный релиз.

Загружаем в папку cstrike папку addons из архива, и переходим в неё, а далее в папку `/metamod`. Удаляем файл `metamod.dll`, поскольку он предназначен для Windows.
Здесь же создаём файл `plugins.ini` - он понадобится нам для установки дополнений.

Теперь активируем Metamod, для этого вернёмся в папку cstrike, в которой ищем файл `liblist.gam` и открываем его вашим текстовым редактором. 
Нас интересует параметр `gamedll_linux`.
Заменяем его значение на путь до .so-файла Metamod.
`gamedll_linux "dlls/cs.so"` -> `gamedll_linux "addons/metamod/metamod_i386.so"`
Перезагружаем сервер.

На этом установка Metamod завершена.
Заходим в консоль и убеждаемся в том, что он работает, введя команду `meta version`.
На момент написания статьи вы должны получить вот такой вывод:
```
Metamod-r v1.3.0.128, API (5:13)
Metamod-r build: 17:47:54 Aug 24 2018
Metamod-r from: https://github.com/theAsmodai/metamod-r/commit/0cf2f70
```

### Установка AmxModX
Здесь у вас есть выбор: ставить стабильную ветку разработки (версия 1.9.0) или же экспериментальную (1.10.0), куда вносится новый функционал.
Лично я рекомендую 1.9.0, поскольку если вы не знакомы со скриптингом под AmxModX, версия 1.10.0 не даст вам абсолютно никаких преимуществ.

Итак, переходим по ссылке: [AMX Mod X - Half-Life Scripting for Pros!](https://www.amxmodx.org/downloads-new.php).
Находим самый последний билд, вверху таблицы, нажимаем на значок Linux, и скачиваем там **Base Package**, а так же **Counter-Strike**.
Открываем оба архива, и загружаем в папку cstrike папку addons из них, сначала из Base Package, потом из Counter-Strike, соглашаясь на замену файлов.

Открываем ранее созданный нами файл со списком плагинов для Metamod по пути: `addons/metamod/plugins.ini` и добавляем туда следующую строчку:
```
linux addons/amxmodx/dlls/amxmodx_mm_i386.so
```
Сохраняем и перезапускаем сервер.

Заходим в консоль и убеждаемся, в том что AmxModX работает, введя команду `meta list`. В списке должна быть такая надпись:
```
[ 1] AMX Mod X     RUN   -    amxmodx_mm_i386.so        v1.9.0.5293  ini  Start ANY
```
Если она есть, значит мы всё сделали правильно, и можно переходить к следующему шагу.

#### (Опционально) Проверка дампов падений сервера
Здесь же можно сразу проверить, правильно ли мы настроили показ дампов падений сервера.

Создаём новый файл в любом месте у нас на компьютере и называем его, например, `crash_test.sma`. Открываем его текстовым редактором и копируем туда следующий код:
```
#include <amxmodx>
#include <fakemeta>

public plugin_init()
{
    register_plugin("Crash", "1.0", "Dev-CS Team");

    // Generate exception code 0xC0000005
    set_task(1.0, "GenerateExceptionCode");
}

public GenerateExceptionCode()
{
    server_print("[Crash]: I call segmentation fault! Exception code: 0xC0000005");

    // Put invalid pointer that will be generate access violation exception
    set_tr2(0xDEADBEEF, TR_InWater, true);
}
```
Сохраняем.

Далее у нас есть два пути: скомпилировать файл на Windows или на Linux.
Те, кто умеет компилировать плагины на Windows, могут скомпилировать его и переходить к следующему шагу с установкой.

Для остальных я вкратце расскажу, как скомпилировать плагин на Linux.
Полная статья: [Локальное компилирование плагинов | Dev-CS.ru](https://dev-cs.ru/threads/246/)

В FileZilla идём по пути `serverfiles/cstrike/addons/amxmodx/scripting`.
Загружаем сюда наш файл `crash_test.sma`.
Находим файл `amxxpc`, кликаем на него правой кнопкой мыши и выбираем пункт *Права доступа к файлу*. В поле для ввода вписываем права `754` -> OK.

Открываем PuTTY. Теперь нам надо убедться, что мы в корневой папке пользователя, командой:
```
cd
```
Далее переходим в папку, куда мы поместили исходник плагина с краш-тестом:
```
cd serverfiles/cstrike/addons/amxmodx/scripting
```
Запускаем компиляцию:
```
./amxxpc crash_test.sma
```
Если вы увидели такой вывод на экран, значит вы сделали всё правильно:
```
AMX Mod X Compiler 1.9.0.5293
Copyright (c) 1997-2006 ITB CompuPhase
Copyright (c) 2004-2013 AMX Mod X Team

Header size:            300 bytes
Code size:              288 bytes
Data size:              456 bytes
Stack/heap size:      16384 bytes
Total requirements:   17428 bytes
Done.
```
Не забывайте снова вернуться в корневую папку пользователя командой `cd`.

Дальше разворачиваем опять FileZilla, находим в той же папке scripting наш новый файл `crash_test.amxx` (не .sma!) и перетаскиваем его на две точки вверху, чтобы переместить в директорию выше.

Следуем стандартной процедуре установки плагинов: перетаскиваем файл в папку plugins, переходим в папку configs, находим там файл `plugins.ini` и вставляем в самый конец: `crash_test.amxx`. Сохраняем.

Теперь перезагрузим наш сервер и посмотрим, что получилось. В терминале выполняем: `./csserver r`.
***Не забудьте*** сразу отключить плагин краш-теста сервера! Закомментируйте или удалите его название в `plugins.ini`.

Разворачиваем FTP и переходим в папку serverfiles. Здесь ищем файл `debug.log` и открываем его.
Если вы видите примерно такое содержание:
```
----------------------------------------------
CRASH: Sat 16 Oct 2021 07:27:08 AM MSK
Start Line: ./hlds_linux -game cstrike -strictportbind +ip 0.0.0.0 -port 27015 +clientport 27005 +map de_dust2 +servercfgfile server.cfg -maxplayers 16 -pingboost 3 -debug -pidfile hlds.5833.pid
[New LWP 5870]
[New LWP 5871]
[New LWP 5876]
[New LWP 5877]
[New LWP 5878]
[New LWP 5879]
[New LWP 5880]
[New LWP 5881]
[New LWP 5872]
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".
Core was generated by `./hlds_linux -game cstrike -strictportbind +ip 0.0.0.0 -port 27015 +clientport'.
Program terminated with signal SIGSEGV, Segmentation fault.
#0  0xf265935b in set_tr2(tagAMX*, int*) () from cstrike/addons/amxmodx/modules/fakemeta_amxx_i386.so
[Current thread is 1 (Thread 0xf7b8c700 (LWP 5870))]
#0  0xf265935b in set_tr2(tagAMX*, int*) () from cstrike/addons/amxmodx/modules/fakemeta_amxx_i386.so
#1  0xf293bb08 in CLog::LogError(char const*, ...)::msg () from /home/cs/serverfiles/cstrike/addons/amxmodx/dlls/amxmodx_mm_i386.so
#2  0xf24f9454 in ?? ()
Backtrace stopped: previous frame inner to this frame (corrupt stack?)
No symbol table info available.
From        To          Syms Read   Shared Object Library
0xf7f5b130  0xf7f5c1c4  Yes (*)     /lib/i386-linux-gnu/libdl.so.2
0xf7ecd914  0xf7f13c78  Yes         ./libstdc++.so.6
0xf7d8b170  0xf7e4c4af  Yes (*)     /lib/i386-linux-gnu/libm.so.6
0xf7bbc0e0  0xf7d08d76  Yes (*)     /lib/i386-linux-gnu/libc.so.6
0xf7f6f090  0xf7f8a50b  Yes (*)     /lib/ld-linux.so.2
0xf7b8fe04  0xf7b9f490  Yes         ./libgcc_s.so.1
0xf74b02b0  0xf75a0660  Yes (*)     /home/cs/serverfiles/engine_i486.so
0xf74733d0  0xf7476cb4  Yes (*)     /lib/i386-linux-gnu/librt.so.1
0xf74605c0  0xf746ad74  Yes (*)     ./libsteam_api.so
0xf74425e0  0xf7451eff  Yes (*)     /lib/i386-linux-gnu/libpthread.so.0
0xf7417e00  0xf7433838  Yes (*)     /home/cs/serverfiles/filesystem_stdio.so
0xf567e000  0xf6bdb0c4  Yes (*)     /home/cs/.steam/sdk32/steamclient.so
0xf2cfa6a0  0xf2d3cf70  Yes (*)     /home/cs/serverfiles/./cstrike/addons/metamod/metamod_i386.so
0xf2a95280  0xf2c2c0b0  Yes (*)     /home/cs/serverfiles/cstrike/dlls/cs.so
0xf2779a20  0xf27dcdb7  Yes (*)     /home/cs/serverfiles/cstrike/addons/amxmodx/dlls/amxmodx_mm_i386.so
0xf2702b60  0xf274a624  Yes (*)     cstrike/addons/amxmodx/modules/hamsandwich_amxx_i386.so
0xf2671120  0xf2677404  Yes (*)     cstrike/addons/amxmodx/modules/csx_amxx_i386.so
0xf262f9d0  0xf265bd6c  Yes (*)     cstrike/addons/amxmodx/modules/fakemeta_amxx_i386.so
0xf0328000  0xf18468a4  Yes (*)     ./steamclient.so
0xf2260670  0xf22d6020  Yes (*)     ./crashhandler.so
0xf24db300  0xf24e1cd4  Yes (*)     /lib/i386-linux-gnu/libnss_files.so.2
0xf24d21c0  0xf24d51f4  Yes (*)     /lib/i386-linux-gnu/libnss_dns.so.2
0xf24ba3a0  0xf24c6014  Yes (*)     /lib/i386-linux-gnu/libresolv.so.2
(*): Shared library is missing debugging information.
Stack level 0, frame at 0xff9c4734:
 eip = 0xf265935b in set_tr2(tagAMX*, int*); saved eip = 0xf293bb08
 called by frame at 0xff9c4738
 Arglist at 0xff9c472c, args: 
 Locals at 0xff9c472c, Previous frame's sp is 0xff9c4734
 Saved registers:
  ebx at 0xff9c4728, ebp at 0xff9c472c, esi at 0xff9c4720, edi at 0xff9c4724, eip at 0xff9c4730
End of crash report
----------------------------------------------
```
Значит у вас всё получилось.
В противном случае вы увидите урезанный краш-лог:
```
----------------------------------------------
CRASH: Wed 13 Oct 2021 09:16:04 PM MSK
Start Line: ./hlds_linux -game cstrike -strictportbind +ip 0.0.0.0 -port 27015 +clientport 27005 +map de_dust2 +servercfgfile server.cfg -maxplayers 16 -pingboost 3 -debug -pidfile hlds.20701.pid
End of crash report
----------------------------------------------
```
Попробуйте перечитать и выполнить заново шаг с активацией полных краш-логов.

##### Литература
- [Как получить Dump падения HLDS | Dev-CS.ru](https://dev-cs.ru/threads/1532/)
- [Локальное компилирование плагинов | Dev-CS.ru](https://dev-cs.ru/threads/246/)

### Настройка быстрой загрузки файлов
Итак, для полноценной работы сервера нам необходимо настроить быструю загрузка файлов (FastDL).
В противном случае, если у вас не стандартный сервер с дополнительными ресурсами, никто не захочет качать их по 10 минут.

Начнём с установки веб-сервера Nginx. Пишем:
```
sudo apt install nginx
```
После установки он автоматически начнёт свою работу. Проверить это можно зайдя на адрес нашего сервера в браузере. Если вы видите страницу с текстом: `# Welcome to nginx!`, значит всё прошло успешно. 

Теперь перейдён к конфигурации Nginx под сервер быстрой загрузки.
Для этого заходим под root пользователем через FileZilla, и идём по следующему пути: `/etc/nginx/sites-available`. Здесь будет находиться файл конфига nginx по умолчанию (`default`).
Открываем его для редактирования. В разделе **server**, перед закрывающей скобкой '}', вставляем следующее:
```
	# Быстрая загрузка для Counter-Strike
	location /cstrike/ {
		alias   /home/cs/knife/serverfiles/cstrike/;
		autoindex on;

		location ~* (\.wad$|(maps|sprites|models|gfx|sound|media|overviews)/.*(bsp|mdl|spr|wav|mp3|bmp|tga|txt|res)$) {
			allow all;
		}

		deny all;
	}
```
Где `/home/public_server/serverfiles/cstrike/` - это путь до папки cstrike на нашем сервере. Проверьте его и исправьте на свой вариант, если он отличается.
Сохраняем этот файл и проверяем его на корректность. Для этого нам понадобится такая команда:
```
sudo nginx -t
```
Если мы получили сообщение, что все конфиги в порядке, перезагружаем Nginx:
```
sudo service nginx restart
```
Теперь можно проверить, что у нас получилось. Снова открываем браузер, заходим на наш веб сервер и пытаемся скачать какой-нибудь файл, например карту **de_dust2**.
```
http://адрес_сервера/fastdl/maps/de_dust2.bsp
```
Если она скачалась, значит вы всё сделали правильно!

Теперь откроем конфиг игрового сервера (**server.cfg**) и добавим туда следующие квары:
```
sv_allowdownload 1
sv_downloadurl "http://адрес_сервера/fastdl/"
```

На этом основная настройка сервера завершена!

#### Литература
- [Как установить LEMP на Debian 9 – База знаний Timeweb Community](https://timeweb.com/ru/community/articles/kak-ustanovit-lemp-na-debian-9-1)
- [Правильная настройка FastDL на VDS (c-s.net.ua)](https://c-s.net.ua/forum/topic67228s60.html#entry1045699)

## Часть 4. Дополнительные инструменты для сервера. Рекомендации

### Установка компонентов веб-сервера
Большинство серверодержателей наверняка захотят установить CSBans или другие веб-дополнения. Я расскажу, как установить основные необходимые для этого инструменты: PHP и MySQL.

#### Установка MySQL
Начнём мы с установки СУБД. Выполнять следующие команды лучше под root пользователем.
Перейдём в корневую папку системы, затем в папку для временных данных:
```
cd / && cd tmp
```
Поскольку в Debian MySQL не включена в стандартный набор пакетов, нам надо вручную добавить её туда следующим образом:
```
wget https://repo.mysql.com//mysql-apt-config_0.8.18-1_all.deb
```
```
apt install ./mysql-apt-config_0.8.18-1_all.deb -y
```
На момент написания статьи в этом пакете ещё нет поддержки Debian 11, он прекрасно работает и без этого. На экране появится выбор дистрибутива, и нам нужно выбрать Debian 10 (buster). На следующем экране просто нажимаем ОК.

Теперь обновим список пакетов и установим MySQL:
```
apt update && apt install mysql-server
```
На текущем этапа у нас попросят задать пароль для root пользователя, а дальше использовать новую аутентификацию MySQL 8. Жмём `Use Strong Password Encryption (Recommended)`.

После завершения установки, можно убедиться что БД работает при помощи команды `systemctl status mysql`.
Но на этом установка не завершена. Сейчас необходимо выполнить первичную настройку безопасности. Пишем:
```
mysql_secure_installation
```
После ввода пароля root пользователя MySQL (**не Debian**) вам предложат:
- Использовать компонент VALIDATE PASSWORD (n)
- Сменить пароль для пользователя root (n)
- Удалить анонимных пользователей (y)
- Запретить удаленный вход в систему из-под **root** (y)
- Удалить тестовую базу данных (y)
- Перезагрузить таблицу привилегий (y)

В скобках я привёл свои варианты ответа.

##### Литература
- [Install MySQL 8 on Debian 11 - kifarunix.com](https://kifarunix.com/install-mysql-8-on-debian-11/)

#### Установка PHP
Данное действие почти не займёт у вас времени, поскольку PHP не нуждается в дополнительной настройке.

Вводим в консоль:
```
apt install php-fpm php-mysql
```
На этом установка завершена. Но на всякий случай проверим, всё ли в порядке.
Переходим в FileZilla по следующему пути: `/var/www/html`.
Здесь создаём файл `info.php`. Открываем его и вставляем туда следующее содержание:
```
<?php

 phpinfo();

?>
```
Сохраняем.

В браузере переходим по адресу нашего файла, т.е.: `http://адрес_сервера/info.php`.
Если вы видите страницу с конфигурацией php, значит вы всё сделали правильно.

##### Литература
- [Как установить LEMP на Debian 9 – База знаний Timeweb Community](https://timeweb.com/ru/community/articles/kak-ustanovit-lemp-na-debian-9-1)


#### (Опционально) Установка Phpmyadmin
Если вам не нужна панель для управления базами данных MySQL, можете пропустить этот шаг.

Для начала установим необходимые компоненты:
```
apt install php-mbstring mcrypt
```
Теперь приступим к установке самой утилиты:
```
apt install phpmyadmin
```
Сначала нам будет предложено выбрать сервер для работы с приложением. К сожалению, Nginx нет в списке, так что снимаем выбор с обеих строк и нажимаем ОК.
Следующим шагом будет автоматическое создание баз данных для phpmyadmin, соглашаемся.
После этого у нас попросят ввести пароль для пользователя phpmyadmin. Вводим.

Затем нам понадобится включить расширение `mcrypt`, что мы и делаем:
```
phpenmod mcrypt
```
И последний шаг. Открываем уже знакомый нам конфиг Nginx по пути `/etc/nginx/sites-available`.
Находим следующую строку:
```
	# Add index.php to the list if you are using PHP
	index index.html index.htm index.nginx-debian.html;
```
Добавляем в этот список `index.php`. Должно получиться так:
```
	# Add index.php to the list if you are using PHP
	index index.php index.html index.htm index.nginx-debian.html;
```
Затем вставляем в конец общего раздела конфигурацию для phpmyadmin:
```
	# Конфигурация для phpmyadmin
	location /phpmyadmin {
		alias /usr/share/phpmyadmin/;

		location ~ \.php$ {
			fastcgi_pass unix:/var/run/php/php7.4-fpm.sock;
			fastcgi_index index.php;
			fastcgi_param SCRIPT_FILENAME $request_filename;
			include fastcgi_params;
			fastcgi_ignore_client_abort off;
		}

		location ~* \.(js|css|png|jpg|jpeg|gif|ico)$ {
			access_log    off;
			log_not_found    off;
			expires 1M;
		}
	}
```
Сохраняем файл. Как обычно проверяем конфигурацию командой `nginx -t`, исправляем ошибки, если они есть. Перезагружаем Nginx.
На этом всё!

Теперь идём смотреть, что у нас получилось. В браузере переходим по ссылке: `http://адрес_сервера/phpmyadmin`. Если вы видите страницу входа в phpmyadmin, значит установка прошла успешно.

##### Литература
- [Как установить phpMyAdmin – База знаний Timeweb Community](https://timeweb.com/ru/community/articles/kak-ustanovit-phpmyadmin)

### Включение оповещений о некорректной работе сервера
В LGSM так же можно включить оповещения о недоступности сервера, если команда `monitor` её выявила.

Есть довольно большой список мессенджеров и служб для оповещения, но они больше популярны на западе, чем в странах СНГ.
Для нас можно выделить Email, Telegram и Discord. С полным списком можно ознакомиться здесь: [Alerts - LinuxGSM_](https://docs.linuxgsm.com/alerts).

Здесь я рассмотрю подключение к Telegram.

#### Оповещения через Telegram
Итак, первое, что нам нужно сделать, это создать бота в телеграме.

Переходим по этой ссылке [Telegram: Contact @BotFather](https://t.me/BotFather) или ищем в телеграме @BotFather, если он у вас не установлен на компьютере.

Запускаем этого бота и выполняем команду `/newbot`.
Следуя инструкциям, задаём боту имя и никнейм. В результате у нас появится токен бота, который нам надо будет указать в настройках скрипта.

Открываем конфиг LGSM по уже знакомому нам пути:`lgsm/config-lgsm/csserver/csserver.cfg`.
В самый конец добавляем:
```
## Notification Alerts
# (on|off)

# More info | https://docs.linuxgsm.com/alerts#more-info
postalert="on"

# Telegram Alerts | https://docs.linuxgsm.com/alerts/telegram
# You can add a custom cURL string eg proxy (useful in Russia) in "curlcustomstring".
# For example "--socks5 ipaddr:port" for socks5 proxy see more in "curl --help".
telegramalert="on"
telegramtoken="token"
telegramchatid="chatid"
```
Итак, рассмотрим приведённые здесь параметры.
- `postalert` - позволяет получить дополнительную информацию о сервере на момент неисправности и загружает её на Termbin, аналогично команде `./csserver postdetails`.
- `telegramalert` - собственно, включить или нет оповещения в Telegram.
- `telegramtoken` - сюда нужно вставить токен нашего нового бота.
- `telegramchatid` - здесь надо указать индекс вашего с ботом чата. Об этом ниже.

Вставляем полученный на предыдущем шаге индекс бота в параметр `telegramtoken`.
Затем в браузере переходим по следующему пути:
```
https://api.telegram.org/botXXXXXXXXX:XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX/getUpdates
```
Где `XXXXXXXXX:XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX` - заменяем на токен бота. Например:
```
https://api.telegram.org/bot3104437352:AAE2XjHxOIBbfM2U1HStmcOkLdCTw5DJsjY/getUpdates
```
Оставляем вкладку открытой.

Теперь пишем боту любое сообщение, например `LGSM test`. Затем обновляем страницу, и у нас должны появиться технические параметры сообщения.
Ищем наше сообщение в конце строки и двигаемся к её началу, чтобы найти данные примерно такого вида: `"chat":{"id":845483018,`.
Число `845483018` - это и будет индекс чата, который нам нужен. Копируем его и вставляем в параметр `telegramchatid`.

Закрываем конфиг и сохраняем его. На этом настройка оповещений завершена. 

Мы можем проверить их работоспособность. Для этого воспользуемся командой скрипта `./csserver test-alert`.
В результате её выполнения нам в телеграм должен написать наш новый бот с тестовым оповещением.

##### Литература
- [Telegram - LinuxGSM_](https://docs.linuxgsm.com/alerts/telegram)
***Примечание***: здесь же можно найти инструкцию о том, как подключить бота к группе, а не только к личному чату.

***Примечание***: На момент написания статьи оповещение в телеграм выдаёт ошибку.
Чтобы её исправить, я использовал код из предыдущего коммита в необходимом файле (`alert_telegram.sh`).
Так же я отправил разработчикам баг-репорт. Надеюсь, в скором времени они исправят этот баг.

# На этом всё. Удачи в создании сервера.
[^1]: CVar - Console Variable, консольная переменная
